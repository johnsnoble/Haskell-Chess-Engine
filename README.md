# Chess

To test the code load the evaluation functions by entering
```
ghci Eval
```
To test the code I used a scenario where black can checkmate in 2 moves called t0. We can see the board we are using by entering
```
printSt t0
```
In order to check if its works we need to look 5 moves ahead and we can do that by using any of the functions :
```
bestMove, ab, stEval :: Int -> State -> (Int,Move)
```
The return value is a tuple of an Int representing an expected score using heurestics and the corresponding move that will guarantee at least that score.
For the first two evaluation functions, looking 5 moves ahead will take around 4-7 mins so I created another state t1 which is the state where the best move was applied to t0.
From t1 the checkmate from black can be seen from a depth of 4 which allows us to test the evaluations much quicker.

***1. bestMove***
bestMove is a very basic variation minmax algorithm which simply generates all possible moves and recursively finds the expected score based on applying the same algorithm to all the states generated by all possible moves.
bestMove can find the best move from t1 to a depth of 4 in around 25-30s

***2. ab***
ab builds on bestMove but uses alpha beta pruning in order to remove a bunch of redundant computation.
Finds best move from t1 to a depth of 4 in around 20s

***3. stEval***
stEval builds on ab however stEval takes advantage of a transposition table. It is essentially a makeshift hashtable that is initialised, updated and queried in the ST Monad.
There are two tables the TransTable : which is a table that stores the evaluated value of a state at the index of its hash value, and
StateTable : which is a table that stores the actual state at the index of its hashed value so that we can double check that it is the correct state when we find a non null evaluated value in the TransTable.
This helped a lot and bought the time taken to find the best move from t1 to a depth of 4 in around 10s. It can even look 5 moves ahead from t0 in 2 mins.
